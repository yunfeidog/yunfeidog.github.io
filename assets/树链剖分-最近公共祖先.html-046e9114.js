import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as c,c as l,b as n,d as s,e as t,a as p}from"./app-51564aae.js";const i={},u=n("h1",{id:"树链剖分",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#树链剖分","aria-hidden":"true"},"#"),s(" 树链剖分")],-1),k={href:"https://oi-wiki.org/graph/hld/",target:"_blank",rel:"noopener noreferrer"},r={href:"https://www.bilibili.com/video/BV1tY4y1G7em/?spm_id_from=333.999.0.0&vd_source=c473bb1aae89eee47588dfc50fe8dc40%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%A0%91%E4%B8%8A%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84%E5%88%92%E5%88%86%E6%88%90%E4%B8%8D%E8%B6%85%E8%BF%87$O(logn)$%E6%9D%A1%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%93%BE%EF%BC%8C%E6%AF%8F%E6%9D%A1%E9%93%BE%E4%B8%8A%E7%9A%84%E7%82%B9%E6%B7%B1%E5%BA%A6%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%EF%BC%88%E5%8D%B3%E6%98%AF%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%B8%80%E6%9D%A1%E9%93%BE%EF%BC%8C%E9%93%BE%E4%B8%8A%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84",target:"_blank",rel:"noopener noreferrer"},d=n("p",null,[s("重链剖分可以将树上的任意一条路径划分成不超过"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 LCA 为链的一个端点)。")],-1),m=p('<p>重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。</p><figure><img src="https://cdn.jsdelivr.net/gh/yunfeidog/picture-bed@main/img/202305041321085.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="一些重要的概念" tabindex="-1"><a class="header-anchor" href="#一些重要的概念" aria-hidden="true">#</a> 一些重要的概念</h2><ul><li><p>重儿子：父节点的所有儿子中子树节点数目最多的结点</p></li><li><p>轻儿子：父节点中除重儿子以外的儿子</p></li><li><p>重边：父节点喝重儿子连成的边</p></li><li><p>轻边：父节点和轻儿子连成的边</p></li><li><p>重链：由多条重边链接而成的路径</p></li></ul>',4),v=n("blockquote",null,[n("p",null,"性质："),n("ol",null,[n("li",null,"整棵树会被剖分成若干条重链"),n("li",null,"轻儿子一定是每条重链的顶点"),n("li",null,[s("任意一条路径被分成不超过"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"logn")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n")])])]),s("条链")])])],-1),b=p('<p>在代码中的含义</p><ul><li><code>fa[u]</code>表示存u的父节点</li><li><code>dep[u]</code>存u的深度</li><li><code>son[u]</code>存u的重儿子</li><li><code>sz[u]</code>存以u为根的子树的节点数</li><li><code>top[u]</code>存u所在重链的顶点</li><li><code>dfs1(int u,int father)</code> u为当前节点，father为父节点，该函数为了求出<code>fa,dep,son</code>数组</li><li><code>dfs2(int u,int t)</code>u为当前节点，t为链头，该函数为了求出<code>top</code>数组</li></ul><h2 id="最近公共祖先-lca" tabindex="-1"><a class="header-anchor" href="#最近公共祖先-lca" aria-hidden="true">#</a> 最近公共祖先(LCA)</h2>',3),h={href:"https://www.luogu.com.cn/problem/P3379",target:"_blank",rel:"noopener noreferrer"},f=p(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>  <span class="token comment">// 树链剖分模板（轻重链剖分）</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">int</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span>
  <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>

  <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> root<span class="token punctuation">;</span>
  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储树的边</span>
  <span class="token keyword">int</span> fa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> son<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> dep<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>sz<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 分别为父节点、重儿子、深度、以该点为根的子树大小</span>
  <span class="token keyword">int</span> top<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前节点所在重链的顶部</span>

  <span class="token keyword">void</span> <span class="token function">dfs1</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> father<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第一次dfs，确定重儿子和子树大小</span>
      fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> father<span class="token punctuation">,</span> dep<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> dep<span class="token punctuation">[</span>father<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sz<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 记录父节点、深度、以u为根的子树大小</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> father<span class="token punctuation">)</span>
              <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// 防止向上找到父亲节点</span>
          <span class="token function">dfs1</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// dfs该儿子节点</span>
          sz<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+=</span> sz<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// 维护以u为根的子树大小</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>sz<span class="token punctuation">[</span>son<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> sz<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 更新重儿子</span>
              son<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">dfs2</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 第二次dfs，确定每个节点所在重链的顶部</span>
      top<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment">// 当前节点所在重链的顶部为t</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>son<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token comment">// 没有重儿子，直接退出</span>
      <span class="token function">dfs2</span><span class="token punctuation">(</span>son<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归处理重儿子</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> e<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">||</span> v <span class="token operator">==</span> son<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
              <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 处理轻儿子时跳过重儿子和父亲节点</span>
          <span class="token function">dfs2</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 搜轻儿子，并以轻儿子为顶部继续dfs</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">lca</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 查询x、y两个点的LCA（最近公共祖先）</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>top<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span>top<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果x、y不在同一条重链上，则将深度较大的节点往上跳</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>dep<span class="token punctuation">[</span>top<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> dep<span class="token punctuation">[</span>top<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 保证x节点所在的重链深度不小于y节点所在的重链深度</span>
              <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
          x <span class="token operator">=</span> fa<span class="token punctuation">[</span>top<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> dep<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dep<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> y<span class="token punctuation">;</span>  <span class="token comment">// 最终结果为x、y所在链的最近公共祖先，即depth更浅的那个节点</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> m <span class="token operator">&gt;&gt;</span> root<span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
          cin <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>
          e<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 添加树的边，注意无向图要存两遍</span>
          e<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">dfs1</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行dfs1，确定重儿子和以该点为根的子树大小</span>
      <span class="token function">dfs2</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行dfs2，确定每个节点所在重链的顶部</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
          cin <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">;</span>
          cout <span class="token operator">&lt;&lt;</span> <span class="token function">lca</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 查询x、y的LCA</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">signed</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">ONLINE_JUDGE</span></span>
      <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">&quot;../test.in&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">&quot;../test.out&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;w&quot;</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
      <span class="token keyword">int</span> _ <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>_<span class="token operator">--</span><span class="token punctuation">)</span>
          <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1);function y(w,g){const a=e("ExternalLinkIcon");return c(),l("div",null,[u,n("p",null,[n("a",k,[s("OI Wiki"),t(a)]),s(" [视频链接]("),n("a",r,[s("https://www.bilibili.com/video/BV1tY4y1G7em/?spm_id_from=333.999.0.0&vd_source=c473bb1aae89eee47588dfc50fe8dc40重链剖分可以将树上的任意一条路径划分成不超过$O(logn)$条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的"),t(a)]),s(" LCA 为链的一个端点)")]),d,m,v,b,n("p",null,[n("a",h,[s("OJ"),t(a)])]),f])}const x=o(i,[["render",y],["__file","树链剖分-最近公共祖先.html.vue"]]);export{x as default};
