const n=JSON.parse('{"key":"v-5b76ce02","path":"/java/5-%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"RabbitMQ面试题","lang":"zh-CN","frontmatter":{"title":"RabbitMQ面试题","date":"2024-02-17T00:00:00.000Z","category":["中间件","RabbitMQ"],"tag":["中间件","RabbitMQ"],"description":"RabbitMQ面试题 RabbitMQ如何保证消息不丢失 出现消息丢失可能会出现在以下场景： 异步发送（验证码，短信，邮件） MySQL和Redis，ES之间的数据同步 分布式事务 削峰消谷 总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息 解决办法：生产者确认机制： 生产者确认机制是指生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。 消息失败之后如何处理呢？ 回调方法即时重发 记录日志 保存到数据库然后定时重发，成功发送后即刻删除表中的数据 MQ宕机导致消息丢失： 解决办法：消息持久化 MQ默认是内存存储消息，开启持久化可以确保缓存中MQ消息不丢失 主要是交换机，队列，消息持久化 交换机持久化 @Bean public DirectExchange simpleExchange(){ //三个参数分别是：交换机名称，durable是否持久化，autoDelete是否自动删除 return new DirectExchange(\\"simple.direct\\",true,true); } 队列持久化 @Bean public Queue simpleQueue1(){ //使用QueueBuilder创建队列，durable就是持久化 return QueueBuilder.durable(\\"simple.queue1\\").build(); } 消息持久化,通过MessageDeliveryMode.PERSISTENT实现 Message message = MessageBuilder .withBody(\\"hello\\".getBytes(StandardCharsets.UTF_8)) .setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();// 持久化消息 解决办法消费者确认机制 RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP.则允许配置三种确认模式： manual:手动ack,需要在业务代码结束后，调用api发送ack。 auto:自动ack,由spring监测listener代码是香出现异常，没有异常则返回ack;抛出异常则返回nack none:关闭ack,MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除 我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理 image-20240217082251946","head":[["meta",{"property":"og:url","content":"https://github.com/yunfeidog/java/5-%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"全民制作人ikun"}],["meta",{"property":"og:title","content":"RabbitMQ面试题"}],["meta",{"property":"og:description","content":"RabbitMQ面试题 RabbitMQ如何保证消息不丢失 出现消息丢失可能会出现在以下场景： 异步发送（验证码，短信，邮件） MySQL和Redis，ES之间的数据同步 分布式事务 削峰消谷 总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息 解决办法：生产者确认机制： 生产者确认机制是指生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。 消息失败之后如何处理呢？ 回调方法即时重发 记录日志 保存到数据库然后定时重发，成功发送后即刻删除表中的数据 MQ宕机导致消息丢失： 解决办法：消息持久化 MQ默认是内存存储消息，开启持久化可以确保缓存中MQ消息不丢失 主要是交换机，队列，消息持久化 交换机持久化 @Bean public DirectExchange simpleExchange(){ //三个参数分别是：交换机名称，durable是否持久化，autoDelete是否自动删除 return new DirectExchange(\\"simple.direct\\",true,true); } 队列持久化 @Bean public Queue simpleQueue1(){ //使用QueueBuilder创建队列，durable就是持久化 return QueueBuilder.durable(\\"simple.queue1\\").build(); } 消息持久化,通过MessageDeliveryMode.PERSISTENT实现 Message message = MessageBuilder .withBody(\\"hello\\".getBytes(StandardCharsets.UTF_8)) .setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();// 持久化消息 解决办法消费者确认机制 RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP.则允许配置三种确认模式： manual:手动ack,需要在业务代码结束后，调用api发送ack。 auto:自动ack,由spring监测listener代码是香出现异常，没有异常则返回ack;抛出异常则返回nack none:关闭ack,MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除 我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理 image-20240217082251946"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-28T07:21:55.000Z"}],["meta",{"property":"article:author","content":"全民制作人ikun"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:tag","content":"RabbitMQ"}],["meta",{"property":"article:published_time","content":"2024-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-28T07:21:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ面试题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-28T07:21:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全民制作人ikun\\",\\"url\\":\\"https://github.com/yunfeidog\\"}]}"]]},"headers":[{"level":2,"title":"RabbitMQ如何保证消息不丢失","slug":"rabbitmq如何保证消息不丢失","link":"#rabbitmq如何保证消息不丢失","children":[]},{"level":2,"title":"RabbitMQ消息的重复消费问题如何解决","slug":"rabbitmq消息的重复消费问题如何解决","link":"#rabbitmq消息的重复消费问题如何解决","children":[]},{"level":2,"title":"RabbitMQ中死信交换机（延迟队列有了解过吗）","slug":"rabbitmq中死信交换机-延迟队列有了解过吗","link":"#rabbitmq中死信交换机-延迟队列有了解过吗","children":[]},{"level":2,"title":"如果有100万消息堆积在MQ , 如何解决 ?","slug":"如果有100万消息堆积在mq-如何解决","link":"#如果有100万消息堆积在mq-如何解决","children":[]},{"level":2,"title":"RabbitMQ的高可用机制有了解过嘛","slug":"rabbitmq的高可用机制有了解过嘛","link":"#rabbitmq的高可用机制有了解过嘛","children":[]}],"git":{"createdTime":1708231378000,"updatedTime":1714288915000,"contributors":[{"name":"yunfeidog","email":"1844025705@qq.com","commits":2}]},"readingTime":{"minutes":7.23,"words":2169},"filePathRelative":"java/5-中间件/RabbitMQ面试题.md","localizedDate":"2024年2月17日","excerpt":"<h1> RabbitMQ面试题</h1>\\n<h2> RabbitMQ如何保证消息不丢失</h2>\\n<blockquote>\\n<p>出现消息丢失可能会出现在以下场景：</p>\\n<ul>\\n<li>异步发送（验证码，短信，邮件）</li>\\n<li>MySQL和Redis，ES之间的数据同步</li>\\n<li>分布式事务</li>\\n<li>削峰消谷</li>\\n</ul>\\n<p>总结为：消息未达到交换机，消息未达到队列，队列中丢失消息，消费者未接收到消息</p>\\n<ol>\\n<li>解决办法：生产者确认机制：</li>\\n</ol>\\n<p>生产者确认机制是指生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。</p>\\n<p>消息失败之后如何处理呢？</p>\\n<ul>\\n<li>回调方法即时重发</li>\\n<li>记录日志</li>\\n<li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据</li>\\n</ul>\\n<p>MQ宕机导致消息丢失：</p>\\n<ol start=\\"2\\">\\n<li>解决办法：消息持久化</li>\\n</ol>\\n<p>MQ默认是内存存储消息，开启持久化可以确保缓存中MQ消息不丢失</p>\\n<p>主要是交换机，队列，消息持久化</p>\\n<p>交换机持久化</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token annotation punctuation\\">@Bean</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">DirectExchange</span> <span class=\\"token function\\">simpleExchange</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//三个参数分别是：交换机名称，durable是否持久化，autoDelete是否自动删除</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">DirectExchange</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"simple.direct\\"</span><span class=\\"token punctuation\\">,</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">,</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>队列持久化</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token annotation punctuation\\">@Bean</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">Queue</span> <span class=\\"token function\\">simpleQueue1</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//使用QueueBuilder创建队列，durable就是持久化</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token class-name\\">QueueBuilder</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">durable</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"simple.queue1\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">build</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>消息持久化,通过MessageDeliveryMode.PERSISTENT实现</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token class-name\\">Message</span> message <span class=\\"token operator\\">=</span> <span class=\\"token class-name\\">MessageBuilder</span>\\n        <span class=\\"token punctuation\\">.</span><span class=\\"token function\\">withBody</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"hello\\"</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getBytes</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">StandardCharsets</span><span class=\\"token punctuation\\">.</span><span class=\\"token constant\\">UTF_8</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span>\\n        <span class=\\"token punctuation\\">.</span><span class=\\"token function\\">setDeliveryMode</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">MessageDeliveryMode</span><span class=\\"token punctuation\\">.</span><span class=\\"token constant\\">PERSISTENT</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">build</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">// 持久化消息</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><ol start=\\"3\\">\\n<li>解决办法消费者确认机制</li>\\n</ol>\\n<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP.则允许配置三种确认模式：</p>\\n<ul>\\n<li>manual:手动ack,需要在业务代码结束后，调用api发送ack。</li>\\n<li>auto:自动ack,由spring监测listener代码是香出现异常，没有异常则返回ack;抛出异常则返回nack</li>\\n<li>none:关闭ack,MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li>\\n</ul>\\n<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p>\\n<figure><img src=\\"https://s2.loli.net/2024/02/17/dj2frmUs1uLhOvK.webp\\" alt=\\"image-20240217082251946\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20240217082251946</figcaption></figure>\\n</blockquote>","copyright":{"author":"全民制作人cxk","license":"CC-BY-NC-SA-4.0"},"autoDesc":true}');export{n as data};
